<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TALENT MODULE COACH</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
<style>
  body {font-family: Arial, system-ui, -apple-system; background:#07102a;color:#e6eef8;margin:20px;}
  .card{background:#0b1220;padding:14px;border-radius:14px;margin-bottom:20px;}
  #chatbox{height:420px;overflow:auto;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;display:flex;flex-direction:column;}
  .msg{margin:6px 0;padding:8px;border-radius:8px;max-width:80%;white-space:pre-wrap;}
  .user{background:rgba(99,102,241,0.15);align-self:flex-end;}
  .bot{background:rgba(255,255,255,0.03);align-self:flex-start;}
  .controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap; align-items:flex-start}
  .btn{background:#7c3aed;border:none;padding:6px 12px;border-radius:8px;color:white;cursor:pointer;}
  .small{opacity:.8;font-size:12px;margin-left:8px}
  #userInput {min-width:260px; font-family: inherit; line-height:1.4; resize:none; overflow:hidden;}
  .hidden{display:none}
  .tag{display:inline-block;background:#1a2448;border:1px solid #24305e;border-radius:14px;padding:2px 8px;margin-left:6px;font-size:12px;opacity:.9}
  .chatTable{border-collapse:collapse;margin:6px 0;width:100%;font-size:13px;}
  .chatTable th,.chatTable td{border:1px solid rgba(255,255,255,0.2);padding:4px 6px;}
  .chatTable th{background:rgba(255,255,255,0.1);font-weight:bold;}
  mark{background:#facc15;color:#000;padding:0 2px;border-radius:2px;}
  .sourceTag{display:inline-flex;align-items:center;gap:6px;background:#0f1a3d;border:1px solid #22336b;border-radius:14px;padding:3px 8px;margin:3px 6px 0 0;}
  .sourceTag a{color:#cbd5ff;text-decoration:none}
  .sourceTag a:hover{text-decoration:underline}
  .sourcesWrap{display:flex;flex-wrap:wrap}
  .notice{background:#13213d;border:1px solid #23386b;color:#cfe0ff;padding:6px 10px;border-radius:8px;margin-bottom:6px;font-size:12px;display:flex;align-items:center;gap:8px;}
  .notice::before{content:'âš ï¸';}

  /* Spinner for status */
  .spinner { width:14px; height:14px; border:2px solid rgba(255,255,255,0.25); border-top-color:#cbd5ff; border-radius:50%; animation:spin 0.9s linear infinite; }
  @keyframes spin { from { transform: rotate(0deg);} to { transform: rotate(360deg);} }

  /* Status row */
  .status { display:flex; align-items:center; gap:10px; margin-top:6px; font-size:12px; opacity:.9; }
  .status .bar { width:220px; height:6px; background:rgba(255,255,255,0.15); border-radius:6px; overflow:hidden; }
  .status .bar > span { display:block; height:100%; width:0%; background:#7c3aed; transition:width .2s; }
</style>
</head>
<body>

<div class="card">
  <h2>TALENT MODULE COACH</h2>
  <div>
    Mode: <span id="modeLabel">User</span>
    <span class="small">â€” Excel KB + Multiâ€‘PDF (Configâ€‘driven via OneDrive) â€” User mode reads from cache</span>
  </div>
  <div id="chatbox"></div>

  <div class="controls">
    <div style="flex:1; min-width:280px;">
      <div class="notice">Always review TMCoach answers and never enter PII.</div>
      <textarea id="userInput" placeholder="Ask question + include the module. Ex. Interview Scheduling - Recruiting" rows="1" style="width:100%;"></textarea>
    </div>
    <div style="display:flex;flex-direction:column;gap:8px;">
      <button id="sendBtn" class="btn">Send</button>
      <button id="adminToggleBtn" class="btn" title="Sign in & refresh cache (Admin only)">Admin Login</button>
      <button id="reloadBtn" class="btn" title="Reload cache (no signâ€‘in)">Reload</button>
      <button id="switchBtn" class="btn hidden" title="Switch to another Microsoft account/tenant (Admin)">Switch Account</button>
      <span id="pdfCount" class="tag hidden">PDF: 0</span>
    </div>
  </div>

  <!-- Tiny Sources panel -->
  <div id="sourcesPanel" class="small hidden" style="margin-top:8px;">
    <div style="opacity:.8;margin-bottom:4px;">Sources:</div>
    <div id="sourcesWrap" class="sourcesWrap"></div>
  </div>

  <!-- Loading / progress status -->
  <div id="loadStatus" class="status hidden">
    <div class="spinner"></div>
    <span id="statusText">Loadingâ€¦</span>
    <div class="bar"><span id="statusFill"></span></div>
  </div>
</div>

<script>
// ===== CONFIG =====
const clientId    = "7f3c8426-3ef5-4e28-acf0-5f51224bc0a6";
const redirectUri = "https://jacjessie.github.io/learning-coach/";
const scopes      = "Files.ReadWrite.All User.Read";
const shareLink   = "https://xvxky-my.sharepoint.com/:x:/g/personal/jacjessie_xvxky_onmicrosoft_com/Ef4Mr6_ZWd1Dm0D6mAe2ffkBI4syJuD6xhj-ekpItxdyXw?e=8VIx5C";

// ===== STATE =====
let kb = [], hiddenKb = [], docKb = [], pdfWebUrls = [], pdfNames = [];
let isAdmin = false, accessToken = null, workbookBase = null;
let adminSecret = { mode: "plain", plain: "admin123" };

// ===== CACHE (Option 2) =====
const CACHE_META_KEY = 'tmc_cache_meta_v1';
const CACHE_DOC_PREFIX = 'tmc_cache_doc_v1_';
const DOC_CHUNK_SIZE = 220; // chunks per localStorage item

function saveCacheToLocal(){
  try{
    // Clear old parts
    Object.keys(localStorage).forEach(k => { if (k.startsWith(CACHE_DOC_PREFIX)) localStorage.removeItem(k); });
    // Split docKb into parts
    const parts = Math.ceil(docKb.length / DOC_CHUNK_SIZE);
    for(let i=0;i<parts;i++){
      const slice = docKb.slice(i*DOC_CHUNK_SIZE, (i+1)*DOC_CHUNK_SIZE);
      localStorage.setItem(CACHE_DOC_PREFIX + i, JSON.stringify(slice));
    }
    const meta = {
      ts: Date.now(),
      kb, pdfWebUrls, pdfNames,
      docParts: parts, chunkSize: DOC_CHUNK_SIZE
    };
    localStorage.setItem(CACHE_META_KEY, JSON.stringify(meta));
    addChat("Bot","Cached KB + PDF index for User mode.");
  }catch(err){
    addChat("Bot","Cache save failed (storage quota?): " + err.message);
  }
}
function loadCacheFromLocal(){
  try{
    const metaRaw = localStorage.getItem(CACHE_META_KEY);
    if (!metaRaw) return false;
    const meta = JSON.parse(metaRaw);
    const { ts, kb:ckb, pdfWebUrls:cu, pdfNames:cn, docParts } = meta;
    const arr = [];
    for(let i=0;i<docParts;i++){
      const part = localStorage.getItem(CACHE_DOC_PREFIX + i);
      if (part) arr.push(...JSON.parse(part));
    }
    kb = Array.isArray(ckb) ? ckb : [];
    pdfWebUrls = Array.isArray(cu) ? cu : [];
    pdfNames = Array.isArray(cn) ? cn : [];
    docKb = arr;
    renderSources();
    const when = new Date(ts).toLocaleString();
    addChat("Bot", `Loaded cached KB/PDFs (updated ${when}). No signâ€‘in needed.`);
    // Update UI counts
    const tag=document.getElementById("pdfCount");
    tag.textContent=`PDF: ${docKb.length}`; tag.classList.remove("hidden");
    return true;
  }catch(err){
    addChat("Bot","Cache read failed: " + err.message);
    return false;
  }
}
function clearCache(){
  Object.keys(localStorage).forEach(k => { if (k.startsWith(CACHE_DOC_PREFIX) || k===CACHE_META_KEY) localStorage.removeItem(k); });
  addChat("Bot","Local cache cleared.");
}

// ===== UI =====
function addChat(sender, html){
  const el = document.createElement("div");
  el.className = "msg " + (sender === "User" ? "user" : "bot");
  if(sender === "User") el.textContent = "You: " + html; else el.innerHTML = "Bot:<br>" + markdownTablesToHtml(html);
  const box = document.getElementById("chatbox");
  box.appendChild(el); box.scrollTop = box.scrollHeight;
}
function markdownTablesToHtml(md){
  const blocks = (md || "").split(/\n\s*\n/);
  return blocks.map(block => {
    if (/^\s*\|.*\|\s*$/m.test(block)) {
      const rows = block.trim().split("\n");
      return "<table class='chatTable'>" +
        rows.map((row, idx) => {
          const cols = row.trim().split("|").slice(1, -1).map(c => c.trim());
          if (idx === 1 && /^-+$/.test(cols[0])) return "";
          const tag = (idx === 0) ? "th" : "td";
          return "<tr>" + cols.map(c => `<${tag}>${c}</${tag}>`).join("") + "</tr>";
        }).join("") +
        "</table>";
    }
    return "<p>" + block + "</p>";
  }).join("");
}
function renderSources(){
  const wrap = document.getElementById('sourcesWrap');
  const panel = document.getElementById('sourcesPanel');
  if (!wrap || !panel) return;
  wrap.innerHTML = '';
  const any = pdfWebUrls.length > 0;
  panel.classList.toggle('hidden', !any);
  if (!any) return;
  pdfWebUrls.forEach((url, idx) => {
    const name = (pdfNames[idx] || 'PDF');
    const a = document.createElement('a'); a.href = `${url}#page=1`; a.target = '_blank'; a.textContent = name;
    const span = document.createElement('span'); span.className = 'sourceTag';
    const count = docKb.filter(x => x.pdfIndex === idx).length;
    span.innerHTML = `<span>ðŸ“„</span>`; span.appendChild(a); span.insertAdjacentHTML('beforeend', `<span style="opacity:.7">(${count})</span>`);
    wrap.appendChild(span);
  });
}

// ===== Status / Progress helpers =====
function setStatus(text, ratio){
  const box = document.getElementById('loadStatus');
  const txt = document.getElementById('statusText');
  const fill = document.getElementById('statusFill');
  if (!box || !txt || !fill) return;
  box.classList.remove('hidden');
  txt.textContent = text;
  if (typeof ratio === 'number') {
    const pct = Math.max(0, Math.min(1, ratio)) * 100;
    fill.style.width = pct + '%';
  }
}
function clearStatus(){
  const box = document.getElementById('loadStatus');
  const fill = document.getElementById('statusFill');
  if (box) box.classList.add('hidden');
  if (fill) fill.style.width = '0%';
}

// Auto-expand textarea
const userInput = document.getElementById("userInput");
userInput.addEventListener("input", function(){
  this.style.height = "auto";
  this.style.height = this.scrollHeight + "px";
});

// ===== Query parsing: "question - Module" =====
function parseQueryParts(q){
  const m = q.split(/\s*[-â€“â€”:|]\s*/);
  if (m.length >= 2){
    const module = m[m.length - 1].trim();
    const keywords = m.slice(0, m.length - 1).join(' ').trim();
    return { keywords, module };
  }
  return { keywords: q.trim(), module: '' };
}
function pickModuleIndex(module){
  if (!module) return null;
  let bestIdx = null, bestScore = 0;
  const ml = module.toLowerCase();
  for (let i=0;i<pdfNames.length;i++){
    const nm = (pdfNames[i]||'').toLowerCase();
    const s = normalizedSimilarity(ml, nm);
    if (s > bestScore){ bestScore = s; bestIdx = i; }
  }
  return (bestScore >= 0.42) ? bestIdx : null;
}

// ===== Search (Excel KB + PDF, module only narrows PDFs) =====
function levenshtein(a,b){if(!a||!b) return a||b?Math.max(a.length,b.length):0;const m=a.length,n=b.length,dp=Array(m+1).fill(0).map(()=>Array(n+1).fill(0));for(let i=0;i<=m;i++)dp[i][0]=i;for(let j=0;j<=n;j++)dp[0][j]=j;for(let i=1;i<=m;i++)for(let j=1;j<=n;j++){const c=a[i-1]===b[j-1]?0:1;dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+c);}return dp[m][n];}
function normalizedSimilarity(a,b){a=(a||"").toLowerCase();b=(b||"").toLowerCase();const d=levenshtein(a,b),M=Math.max(a.length,b.length);return M?1-d/M:1;}
function scoreMatch(q,t){return normalizedSimilarity(q,t);} 
function searchAll(query){
  const { keywords, module } = parseQueryParts(query);
  const words = keywords.toLowerCase().split(/\s+/).filter(w=>w.length>2);

  // PDF pool (respect module scope)
  let pdfPool = [...docKb];
  const modIdx = pickModuleIndex(module);
  if (modIdx !== null) pdfPool = pdfPool.filter(k => k.pdfIndex === modIdx);

  // Excel pool
  let kbPool = kb.map(text => ({ text, source:'KB' }));

  // If no keywords provided and only module given, show only PDFs (avoid flooding with all KB rows)
  let combined = (words.length === 0) ? pdfPool : [...pdfPool, ...kbPool];

  // Filter by keywords
  let candidates = words.length ? combined.filter(k => words.some(w => k.text.toLowerCase().includes(w))) : combined;

  const scored = candidates.map(k => {
      const qForScore = keywords || module || '';
      let score = scoreMatch(qForScore, k.text);
      if (k.source === 'PDF') score += 0.15;            // PDF slight boost
      if (k.source === 'KB' && modIdx !== null) score -= 0.05; // if module selected, prefer PDF a bit
      return { item:k, score };
    })
    .sort((a,b)=>b.score-a.score)
    .slice(0, 10);

  return { hits: scored, modIdx, keywords, module };
}
function composeReply(query){
  const { hits, modIdx, keywords, module } = searchAll(query);
  if(hits.length===0)return `No relevant info found.\nTip: Include a module after a dash, e.g. Interview Scheduling - Recruiting`;

  const scope = (modIdx !== null) ? (pdfNames[modIdx] || module || 'PDF') : (module ? module : 'All');

  let reply="Keyword & Module:\n\n| Keyword | Module |\n|---------|--------|\n| "+(keywords||'(none)')+" | "+scope+" |\n\n";
  reply+="Answers Found:\n\n| # | Snippet | Source |\n|---|----------|--------|\n";
  const regex = keywords ? new RegExp(`(${keywords})`,"ig") : null;
  hits.forEach((h,i)=>{
    let snippet=h.item.text.replace(/\n/g," ");
    if(snippet.length>220)snippet=snippet.slice(0,220)+"...";
    if (regex) snippet=snippet.replace(regex,"<mark>$1</mark>");
    let src;
    if(h.item.source==='KB'){
      src = 'Excel KB';
    } else {
      const web=pdfWebUrls[h.item.pdfIndex]||"";
      const label=(pdfNames[h.item.pdfIndex]||'PDF');
      src=web?`<a href="${web}#page=${h.item.page}" target="_blank">${label} p.${h.item.page}</a>`:`${label} p.${h.item.page}`;
    }
    reply+=`| ${i+1} | ${snippet} | ${src} |\n`;
  });
  return reply;
}

// ===== Graph helpers =====
async function gFetch(url,opt={}){
  const res=await fetch(url,opt);
  if(!res.ok){
    let t=""; try{t=await res.text();}catch{};
    throw new Error(`HTTP ${res.status} ${res.statusText}\n${t}`);
  }
  const ct=res.headers.get("content-type")||"";
  if(ct.includes("json"))return res.json();
  if(ct.includes("pdf")||ct.includes("octet"))return res.arrayBuffer();
  return res.text();
}
function toGraphShareId(url){let b=btoa(url).replace(/=+$/,'').replace(/\+/g,'-').replace(/\//g,'_');return 'u!'+b;}

// ===== OAuth =====
function loginMicrosoftGraph(){const tenant="common";const params=new URLSearchParams({client_id:clientId,response_type:"token",redirect_uri:redirectUri,scope:scopes,prompt:"select_account"});window.location.href=`https://login.microsoftonline.com/${tenant}/oauth2/v2.0/authorize?${params}`;}
function getTokenFromHash(){if(window.location.hash){const p=new URLSearchParams(window.location.hash.substring(1));const t=p.get("access_token");if(t){accessToken=t;window.location.hash="";fetchExcelKBAndPdfs(true);}}}

// ===== Excel KB + Config PDFs =====
async function resolveWorkbookBase(){if(workbookBase)return;const shareId=toGraphShareId(shareLink);const item=await gFetch(`https://graph.microsoft.com/v1.0/shares/${shareId}/driveItem`,{headers:{Authorization:"Bearer "+accessToken}});workbookBase=`https://graph.microsoft.com/v1.0/drives/${item.parentReference.driveId}/items/${item.id}/workbook`;}

// Read KB rows (table or range)
async function readKnowledgeRows(){
  try{
    const tData = await gFetch(`${workbookBase}/tables`, { headers:{ Authorization:'Bearer '+accessToken } });
    const t = (tData.value||[]).find(x => (x.name||'').toLowerCase()==='knowledgetable');
    if (t){
      const rowsData = await gFetch(`${workbookBase}/tables('${t.name}')/rows`, { headers:{ Authorization:'Bearer '+accessToken } });
      return (rowsData.value||[]).map(r => (r.values && r.values[0] && r.values[0][0]) ? String(r.values[0][0]).trim() : "").filter(Boolean);
    }
  }catch(e){ /* fall back to range */ }
  try{
    const data=await gFetch(`${workbookBase}/worksheets('Knowledge')/range(address='A2:A20000')`,{headers:{Authorization:'Bearer '+accessToken}});
    const vals=Array.isArray(data.values)?data.values:[];
    return vals.map(r=>(r&&r[0]?String(r[0]).trim():"")).filter(Boolean);
  }catch(err){
    addChat("Bot","Error reading Knowledge: "+err.message);
    return [];
  }
}

// Read PDF links (ConfigTable or ranges)
async function readPdfLinksFromConfig(){
  let entries=[];
  try{
    const tData = await gFetch(`${workbookBase}/tables`, { headers:{ Authorization:'Bearer '+accessToken } });
    const t = (tData.value||[]).find(x => (x.name||'').toLowerCase()==='configtable');
    if (t){
      const headerRes = await gFetch(`${workbookBase}/tables('${t.name}')/headerRowRange`, { headers:{ Authorization:'Bearer '+accessToken } });
      const headers = (headerRes.values && headerRes.values[0]) ? headerRes.values[0].map(v=>String(v).trim().toLowerCase()) : [];
      const nameIdx = headers.indexOf('name');
      const linkIdx = headers.indexOf('pdflink');
      const rowsData = await gFetch(`${workbookBase}/tables('${t.name}')/rows`, { headers:{ Authorization:'Bearer '+accessToken } });
      entries = (rowsData.value||[]).map(r => {
        const row = (r.values && r.values[0]) ? r.values[0] : [];
        const name = nameIdx>=0 ? String(row[nameIdx]||'').trim() : '';
        const link = linkIdx>=0 ? String(row[linkIdx]||'').trim() : '';
        return { name, link };
      }).filter(e => /^https?:\/\//i.test(e.link));
      if (entries.length) return entries;
    }
  }catch(e){ /* fall back to ranges */ }
  try{
    const data=await gFetch(`${workbookBase}/worksheets('Config')/range(address='A2:B200')`,{headers:{Authorization:'Bearer '+accessToken}});
    const vals=Array.isArray(data.values)?data.values:[];
    entries=vals.map(r=>({name:String(r[0]||"").trim(),link:String(r[1]||"").trim()})).filter(e=>/^https?:\/\//i.test(e.link));
    if(entries.length) return entries;
  }catch(e){ /* continue */ }
  try{
    const data=await gFetch(`${workbookBase}/worksheets('Config')/range(address='A2:A200')`,{headers:{Authorization:'Bearer '+accessToken}});
    const vals=Array.isArray(data.values)?data.values:[];
    entries=vals.map(r=>({name:'',link:(r&&r[0]?String(r[0]).trim():"")})).filter(e=>/^https?:\/\//i.test(e.link));
  }catch(err){
    addChat("Bot","Config sheet missing or PDF links not found.");
  }
  return entries;
}

// ===== PDF fetch & indexing (with progress callback) =====
async function fetchSinglePdfFromOneDrive(link, idx, label, onProgress){
  const shareId=toGraphShareId(link);
  const item=await gFetch(`https://graph.microsoft.com/v1.0/shares/${shareId}/driveItem`,{headers:{Authorization:"Bearer "+accessToken}});
  pdfWebUrls[idx]=item.webUrl;
  const buf=await gFetch(`https://graph.microsoft.com/v1.0/drives/${item.parentReference.driveId}/items/${item.id}/content`,{headers:{Authorization:'Bearer '+accessToken}});
  const pdf=await pdfjsLib.getDocument({data:buf}).promise;
  const totalPages = pdf.numPages;
  if (onProgress) onProgress(0, totalPages, label);
  let extracted=0;
  for(let p=1;p<=totalPages;p++){
    const page=await pdf.getPage(p);
    const tc=await page.getTextContent();
    const txt=tc.items.map(it=>it.str).join(" ").replace(/\s+/g," ").trim();
    const chunkSize=500, overlap=80;
    for(let i=0;i<txt.length;i+=(chunkSize-overlap)){
      const chunk=txt.slice(i,i+chunkSize).trim();
      if(chunk.length>60){
        docKb.push({text:chunk,source:'PDF',page:p,pdfIndex:idx});
        extracted++;
      }
    }
    if (onProgress) onProgress(p, totalPages, label);
  }
  addChat("Bot",`Parsed ${label || ('PDF '+(idx+1))}: ${extracted} chunks.`);
}

// ===== Load Excel KB + PDFs (with status) =====
async function fetchExcelKBAndPdfs(isAdminRefresh=false){
  try{
    setStatus('Loading Knowledgeâ€¦', 0);
    await resolveWorkbookBase();

    const knowledgeTexts = await readKnowledgeRows();
    kb = knowledgeTexts; // plain strings
    addChat("Bot","Excel KB loaded.");

    const pdfEntries = await readPdfLinksFromConfig();
    if (!pdfEntries.length){
      clearStatus();
      renderSources();
      addChat("Bot","No PDFs configured in Excel Config sheet.");
      if (isAdminRefresh) saveCacheToLocal();
      return;
    }
    setStatus('Opening PDFsâ€¦', 0);
    pdfWebUrls=[]; pdfNames=[]; docKb=[];
    for(let idx=0; idx<pdfEntries.length; idx++){
      const {name,link}=pdfEntries[idx];
      pdfNames[idx] = name || 'PDF';
      try{
        await fetchSinglePdfFromOneDrive(link, idx, pdfNames[idx], (page,total,label)=>{
          const text = total ? `Scanning ${label}: ${page}/${total} page(s)â€¦` : `Scanning ${label}â€¦`;
          const ratio = total ? (page/total) : 0;
          setStatus(text, ratio);
        });
      }catch(e){
        addChat("Bot",`Error loading PDF ${idx+1}: ${e.message}`);
      }
    }
    clearStatus();
    const total=docKb.length;
    const tag=document.getElementById("pdfCount");
    tag.textContent=`PDF: ${total}`; tag.classList.remove("hidden");
    renderSources();
    addChat("Bot",`Indexed ${total} chunks from ${pdfEntries.length} PDF(s).`);
    if (isAdminRefresh) saveCacheToLocal();
  }catch(err){
    clearStatus();
    addChat("Bot","Error loading KB/PDFs: "+err.message);
  }
}

// ===== Input handlers =====
async function handleInput(){
  const val=document.getElementById("userInput").value.trim();
  if(!val) return;
  document.getElementById("userInput").value="";
  document.getElementById("userInput").style.height="auto";
  addChat("User",val);

  // Hidden admin commands (not exposed in UI)
  if(isAdmin&&val.startsWith('/passwd ')){
    const newPwd=val.slice(8).trim();
    if(!newPwd) return addChat("Bot","Password cannot be empty.");
    await updateAdminPassword(newPwd);
    return;
  }

  addChat("Bot",composeReply(val));
}
document.getElementById("sendBtn").addEventListener("click", handleInput);
document.getElementById("userInput").addEventListener("keydown", e=>{ if(e.key==="Enter" && !e.shiftKey) { e.preventDefault(); handleInput(); } });

// Reload button: user mode -> just reload from cache; admin mode -> refresh from Graph and re-save cache.
document.getElementById("reloadBtn").addEventListener("click", ()=>{
  if (isAdmin && accessToken) { fetchExcelKBAndPdfs(true); }
  else {
    const ok = loadCacheFromLocal();
    if (!ok) addChat("Bot","No local cache found yet. An admin must sign in and refresh cache first.");
  }
});
document.getElementById("switchBtn").addEventListener("click", ()=>{
  accessToken=null; workbookBase=null; kb=[]; hiddenKb=[]; docKb=[]; pdfWebUrls=[]; pdfNames=[]; isAdmin=false;
  document.getElementById('modeLabel').textContent='User';
  document.getElementById('switchBtn').classList.add('hidden');
  renderSources();
  addChat("Bot","Switching accountâ€¦ redirecting to Microsoft sign-in.");
  loginMicrosoftGraph();
});
document.getElementById("adminToggleBtn").addEventListener("click", async ()=>{
  if (isAdmin){
    isAdmin=false; document.getElementById('modeLabel').textContent='User';
    document.getElementById('switchBtn').classList.add('hidden');
    addChat("Bot","Switched to User mode.");
    return;
  }
  if (!accessToken){ addChat("Bot","Opening Microsoft sign-inâ€¦"); return loginMicrosoftGraph(); }
  await resolveWorkbookBase();
  // For Option 2, we don't require password to refresh cache; but we keep it available.
  isAdmin = true;
  document.getElementById('modeLabel').textContent='Admin';
  document.getElementById('switchBtn').classList.remove('hidden');
  addChat("Bot","Admin mode: click Reload to refresh cache from OneDrive.\nAfter it finishes, users wonâ€™t need to sign in.");
  // Immediately refresh cache on entering admin if desired:
  // fetchExcelKBAndPdfs(true);
});

// ===== Admin helpers (for future password feature) =====
function b64enc(arrBuf){ const bytes=new Uint8Array(arrBuf); let bin=""; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
function b64dec(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return bytes.buffer; }
function randomSalt(len=16){ const buf=new Uint8Array(len); crypto.getRandomValues(buf); return b64enc(buf.buffer); }
async function pbkdf2(password, saltB64, iterations=100000, length=32){
  const enc=new TextEncoder();
  const keyMaterial=await crypto.subtle.importKey("raw", enc.encode(password), { name:"PBKDF2" }, false, ["deriveBits"]);
  const salt=b64dec(saltB64);
  const bits=await crypto.subtle.deriveBits({ name:"PBKDF2", hash:"SHA-256", salt, iterations }, keyMaterial, length*8);
  return b64enc(bits);
}
async function updateAdminPassword(newPwd){
  try{
    await resolveWorkbookBase();
    const saltB64 = randomSalt(16);
    const derivedB64 = await pbkdf2(newPwd, saltB64, 100000, 32);
    const kdfDesc = "PBKDF2-100000-SHA256-32";
    await gFetch(`${workbookBase}/worksheets('Admin')/range(address='A1:C1')`, { method:'PATCH', headers:{ Authorization:'Bearer '+accessToken, 'Content-Type':'application/json' }, body: JSON.stringify({ values: [["PasswordHash","Salt","Kdf"]] }) });
    await gFetch(`${workbookBase}/worksheets('Admin')/range(address='A2:C2')`, { method:'PATCH', headers:{ Authorization:'Bearer '+accessToken, 'Content-Type':'application/json' }, body: JSON.stringify({ values: [[derivedB64, saltB64, kdfDesc]] }) });
    addChat("Bot","Admin password updated (hashed) in Excel.");
  }catch(err){ addChat("Bot","Failed to write hashed password: "+err.message); }
}

// ===== Graph helpers used above =====
async function gFetch(url,opt={}){
  const res=await fetch(url,opt);
  if(!res.ok){
    let t=""; try{t=await res.text();}catch{};
    throw new Error(`HTTP ${res.status} ${res.statusText}\n${t}`);
  }
  const ct=res.headers.get("content-type")||"";
  if(ct.includes("json"))return res.json();
  if(ct.includes("pdf")||ct.includes("octet"))return res.arrayBuffer();
  return res.text();
}
function toGraphShareId(url){let b=btoa(url).replace(/=+$/,'').replace(/\+/g,'-').replace(/\//g,'_');return 'u!'+b;}

// ===== Bootstrap =====
function init(){
  // Try to load cache first for User mode
  const ok = loadCacheFromLocal();
  if (!ok){
    addChat("Bot","No cached data yet. An admin should sign in and press Reload to build the cache.");
  }
  // Token capture (in case admin just returned from login)
  getTokenFromHash();
}
init();
</script>
</body>
</html>
